# 设计原则及架构思想

## 编程思想

### 面向对象编程OOP
面向对象编程(Object Oriented Programming，OOP)思想是以现实世界中事物，建立模型体现出来的抽象思维过程。
根据抽象的模型，依照事物之间的关系及方法进行操作，以求达到**重用性**、**灵活性**和**扩展性**的设计目的。
> 面向对象编程是把构成问题的事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是**为了描叙某个事物在整个解决问题的步骤中的行为**。

OOP=对象+类+继承+多态+消息，其中核心概念是类和对象。

特点： 封装、多态、继承

优点:
- 结构清晰，程序是模块化和结构化，更加符合人类的思维方式；
- 易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统；
- 易维护，系统低耦合的特点有利于减少程序的后期维护工作量。

缺点：
- 开销大，当要修改对象内部时，对象的属性不允许外部直接存取，所以要增加许多没有其他意义、只负责读或写的行为。这会为编程工作增加负担，增加运行开销，并且使程序显得臃肿。
- 性能低，由于面向更高的逻辑抽象层，使得面向对象在实现的时候，不得不做出性能上面的牺牲，计算时间和空间存储大小都开销很大。

### 面向过程编程POP
面向过程编程(Procedure-Oriented Programming，简记为POP)，就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。

优点：
- 流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析。
- 效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。

缺点：
- 需要深入的思考，耗费精力，代码重用性低，扩展能力差，后期维护难度比较大。

### 函数式编程
函数式编程类似于面向过程的程序设计，但其思想更接近数学计算。允许把函数本身作为参数传入另一个函数，还允许返回一个函数。是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量。
> 面向过程编程体现的是解决方法的步骤，而函数式编程体现的是**数据集的映射**。

函数式编程关心**数据的映射**，命令式编程关心解决问题的步骤



## 六大设计原则

六大设计原则主要是指：
- **单一职责原则**(Single Responsibility Principle): 一个类或接口只承担一个职责。
- **开闭原则**(Open Closed Principle): 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
- **里氏替换原则**(Liskov Substitution Principle): 子类可以扩展父类的功能，但不能改变原有父类的功能。只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常。
- **迪米特法则**(Law of Demeter)，又叫"最少知道法则" : 最少知道原则，尽量降低类与类之间的耦合
- **接口隔离原则**(Interface Segregation Principle): 建立单一接口，类之间依赖关系应该建立在最小的接口上
- **依赖倒置原则**(Dependence Inversion Principle): 面向接口编程，高层模块不应该依赖于低层模块，而应该依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象
> 把这 6 个原则的首字母(里氏替换原则和迪米特法则的首字母重复，只取一个)联合起来就是：**SOLID**(稳定的)，其代表的含义也就是把这 6 个原则结合使用的好处：建立稳定、灵活、健壮的设计。

### 单一职责原则
单一职责原则(Single Responsibility Principle)：一个类或者**一个方法只负责一项职责**，尽量做到类的只有一个行为原因引起变化。
> 该原则适用于类、接口、方法。

单一职责的好处
1. 复杂性降低，实现什么职责都有清晰明确的定义
2. 可读性高，复杂性降低，可读性自然就提高了
3. 可维护性提高，可读性提高了，那自然更容易维护了
4. 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。


### 里氏替换原则
里氏替换原则(LSP liskov substitution principle)：子类可以扩展父类的功能，但不能改变原有父类的功能。只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常。

在面向对象的语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点：
- 代码共享，减少创建类的工作量，每个子类都拥有父类的属性和方法
- 提高代码的重用性
- 子类可以形似父类，但又异于父类
- 提高代码的可扩展性
- 提高产品或项目的开放性。

继承是侵入性的。只要继承，就必须拥有父类的属性和方法。
- 降低代码的灵活性。子类会多一些父类的约束。
- 增强了耦合性。当父类的常量、变量、方法被修改时，需要考虑子类的修改。

### 依赖倒置原则
依赖倒置原则(dependence inversion principle)：面向接口编程(通过接口作为参数实现应用场景)，高层模块不应该依赖于低层模块，而应该依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。

含义：
- 上层模块不应该依赖下层模块，两者应依赖其抽象
- 抽象不应该依赖细节，细节应该依赖抽象
> 通俗点就是说变量或者传参数，尽量使用抽象类，或者接口。抽象就是接口或者抽象类，细节就是实现类。

依赖倒置原则的使用建议：
1. 每个类尽量都有接口或抽象类，或者接口和抽象类两者都具备。
2. 变量的表面类型尽量是接口或抽象类。
3. 任何类都不应该从具体类派生。
4. 尽量不要重写基类的方法。如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要重写。
5. 结合里氏替换原则使用。

### 接口隔离原则
接口隔离原则(Interface Segregation Principle): 建立单一接口(扩展为类也是一种接口，一切皆接口)

定义：
- 客户端不应该依赖它不需要的接口；
- 类之间依赖关系应该建立在最小的接口上；
> 接口的设计粒度越小，系统越灵活，但是灵活的同时结构复杂性提高，开发难度也会变大，维护性降低。如一个臃肿的接口拆分为三个独立的接口所依赖的原则就是接口隔离原则

### 迪米特法则
迪米特原则(law of demeter LOD)：最少知道原则，尽量降低类与类之间的耦合

迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提升上去。
> 如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。

### 开闭原则
开闭原则(open closed principle)： 指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

为什么要用开闭原则
1. 开闭原则非常著名，只要是做面向对象编程的，在开发时都会提及开闭原则。
2. 开闭原则是最基础的一个原则，前面介绍的5个原则都是开闭原则的具体形态，而开闭原则才是其精神领袖。
3. 开闭原则提高了复用性，以及可维护性。

## MVC 模式
MVC是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。经典MVC模式中，M是指业务模型，V是指用户界面，C则是控制器。
> MVC模式的目的是实现一种动态的程式设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式透过对复杂度的简化，使程序结构更加直观。\
> 使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。其中，View的定义比较清晰，就是用户界面。

- 模型(Model) - 程序员编写程序应有的功能(实现算法等等)、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。
- 视图(View) - 界面设计人员进行图形界面设计。
- 控制器(Controller) - 负责转发请求，对请求进行处理。

## BFF(Backend for Frontend)
BFF，即 Backend For Frontend(服务于前端的后端)，也就是服务器设计 API 时会考虑前端的使用，并在服务端直接进行业务逻辑的处理，又称为用户体验适配器。BFF 只是一种逻辑分层，而非一种技术

BFF 解决了什么问题？\
前端页面时常存在，某个页面需要向 `backend A`、`backend B` 以及 `backend C`...... 发送请求，不同服务的返回值用于渲染页面中不同的 `component`，即一个页面存在很多请求的场景。
有了 BFF 这一层时，我们就不需要考虑系统后端的迁移。后端发生的变化都可以在 BFF 层做一些响应的修改。

![image](https://raw.githubusercontent.com/rbmonster/file-storage/main/learning-note/design/systemdesign/bff.png)

- 多端应用: 为不同的设备提供不同的 API，虽然它们可能是实现相同的功能，但因为不同设备的特殊性，它们对服务端的 API 访问也各有其特点，需要区别处理。
- 服务聚合：BFF 的出现为前端应用提供了一个对业务服务调用的聚合点，它屏蔽了复杂的服务调用链，让前端可以聚焦在所需要的数据上，而不用关注底层提供这些数据的服务。
- 认证、授权、请求记录等通用功能可以在BFF层实现，使用依赖包共享的方式实现。而引入额外的服务层可能导致的请求延迟的情况。

缺点：
- 在基础服务上多加了一层转发，带来了响应时间延迟
- 带来的代码重复和工作量增加

参考资料：
- [BFF —— Backend For Frontend](https://www.jianshu.com/p/eb1875c62ad3)
- [Pattern: Backends For Frontends](https://samnewman.io/patterns/architectural/bff/)
## 系统架构

### 单体

“单体”只是表明系统中主要的过程调用都是**进程内调用**，不会发生**进程间通信**，仅此而已。

对于小型系统——即由单台机器就足以支撑其良好运行的系统，单体不仅易于开发、易于测试、易于部署，且由于系统中各个功能、模块、方法的调用过程都是进程内调用，不会发生进程间通信（Inter-Process Communication，IPC）。
> 单体系统的不足，必须基于软件的性能需求超过了单机，软件的开发人员规模明显超过了“2 Pizza Team”范畴的前提下才有讨论的价值


### 分布式

### 微服务
**微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。**

**微服务的九个核心的业务与技术特征**:
- 围绕业务能力构建（Organized around Business Capability）
- 分散治理（Decentralized Governance）
- 通过服务来实现独立自治的组件（Componentization via Services）
- 产品化思维（Products not Projects）
- 数据去中心化（Decentralized Data Management）
- 强终端弱管道（Smart Endpoint and Dumb Pipe）
- 容错性设计（Design for Failure）
- 演进式设计（Evolutionary Design）
- 基础设施自动化（Infrastructure Automation）

#### 拆分原则
垂直划分优先原则：应该根据业务领域对服务进行垂直划分，让团队能关注业务实现。

持续演进原则： 服务数量在非必要的情况下，应该逐步划分，持续演进，避免服务数量的爆炸性增长


#### DDD 领域驱动
详细见
[DDD设计思想](https://github.com/rbmonster/learning-note/blob/master/src/main/java/com/toc/DDD.md)

## 相关资料
[微服务拆分方法论](https://blog.csdn.net/no_game_no_life_/article/details/103390169)
